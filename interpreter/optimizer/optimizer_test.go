package optimizer_test

import (
	"math"
	"testing"

	. "github.com/onsi/ginkgo"
	. "github.com/onsi/ginkgo/extensions/table"
	. "github.com/onsi/gomega"
	"github.com/relnod/calcgo/interpreter/calculator"
	"github.com/relnod/calcgo/interpreter/optimizer"
	"github.com/relnod/calcgo/parser"
)

func TestOptimizer(t *testing.T) {
	RegisterFailHandler(Fail)
	RunSpecs(t, "Optimizer Suite")
}

var _ = Describe("Optimizer with ast generated by parser", func() {
	test := func(in string, expOAST *optimizer.OptimizedAST, expErr error) {
		ast, errors := parser.Parse(in)
		Expect(errors).To(BeNil())

		oast, err := optimizer.Optimize(&ast)
		Expect(oast).To(Equal(expOAST))
		if expErr != nil {
			Expect(err).To(Equal(expErr))
		} else {
			Expect(err).To(BeNil())
		}
	}
	Describe("without variables", func() {
		DescribeTable("numbers", test,
			Entry("dec stays as is", "1.3", &optimizer.OptimizedAST{
				Node: &optimizer.OptimizedNode{
					Type:        parser.NDec,
					Value:       1.3,
					OldValue:    "",
					IsOptimized: true,
					LeftChild:   nil,
					RightChild:  nil,
				},
			}, nil),
			Entry("int becomes dec", "1", &optimizer.OptimizedAST{
				Node: &optimizer.OptimizedNode{
					Type:        parser.NDec,
					Value:       1.0,
					OldValue:    "",
					IsOptimized: true,
					LeftChild:   nil,
					RightChild:  nil,
				},
			}, nil),
			Entry("bin becomes dec", "0b10", &optimizer.OptimizedAST{
				Node: &optimizer.OptimizedNode{
					Type:        parser.NDec,
					Value:       2.0,
					OldValue:    "",
					IsOptimized: true,
					LeftChild:   nil,
					RightChild:  nil,
				},
			}, nil),
			Entry("hex becomes dec", "0x10", &optimizer.OptimizedAST{
				Node: &optimizer.OptimizedNode{
					Type:        parser.NDec,
					Value:       16.0,
					OldValue:    "",
					IsOptimized: true,
					LeftChild:   nil,
					RightChild:  nil,
				},
			}, nil),
			Entry("expp becomes dec", "2^2", &optimizer.OptimizedAST{
				Node: &optimizer.OptimizedNode{
					Type:        parser.NDec,
					Value:       4.0,
					OldValue:    "",
					IsOptimized: true,
					LeftChild:   nil,
					RightChild:  nil,
				},
			}, nil),
		)

		DescribeTable("operations get calculated", test,
			Entry("addition", "1 + 1", &optimizer.OptimizedAST{
				Node: &optimizer.OptimizedNode{
					Type:        parser.NDec,
					Value:       2.0,
					OldValue:    "",
					IsOptimized: true,
					LeftChild:   nil,
					RightChild:  nil,
				},
			}, nil),
			Entry("subtraction", "1 - 1", &optimizer.OptimizedAST{
				Node: &optimizer.OptimizedNode{
					Type:        parser.NDec,
					Value:       0.0,
					OldValue:    "",
					IsOptimized: true,
					LeftChild:   nil,
					RightChild:  nil,
				},
			}, nil),
			Entry("multiplication", "2 * 1", &optimizer.OptimizedAST{
				Node: &optimizer.OptimizedNode{
					Type:        parser.NDec,
					Value:       2.0,
					OldValue:    "",
					IsOptimized: true,
					LeftChild:   nil,
					RightChild:  nil,
				},
			}, nil),
			Entry("division", "1 / 2", &optimizer.OptimizedAST{
				Node: &optimizer.OptimizedNode{
					Type:        parser.NDec,
					Value:       0.5,
					OldValue:    "",
					IsOptimized: true,
					LeftChild:   nil,
					RightChild:  nil,
				},
			}, nil),
			Entry("handles dividing by zero", "1 / 0", nil, calculator.ErrorDivisionByZero),
			Entry("modulo", "1 % 2", &optimizer.OptimizedAST{
				Node: &optimizer.OptimizedNode{
					Type:        parser.NDec,
					Value:       1.0,
					OldValue:    "",
					IsOptimized: true,
					LeftChild:   nil,
					RightChild:  nil,
				},
			}, nil),
			Entry("or", "1 | 1", &optimizer.OptimizedAST{
				Node: &optimizer.OptimizedNode{
					Type:        parser.NDec,
					Value:       1.0,
					OldValue:    "",
					IsOptimized: true,
					LeftChild:   nil,
					RightChild:  nil,
				},
			}, nil),
			Entry("xor", "1 ^ 1", &optimizer.OptimizedAST{
				Node: &optimizer.OptimizedNode{
					Type:        parser.NDec,
					Value:       0.0,
					OldValue:    "",
					IsOptimized: true,
					LeftChild:   nil,
					RightChild:  nil,
				},
			}, nil),
			Entry("and", "1 & 1", &optimizer.OptimizedAST{
				Node: &optimizer.OptimizedNode{
					Type:        parser.NDec,
					Value:       1.0,
					OldValue:    "",
					IsOptimized: true,
					LeftChild:   nil,
					RightChild:  nil,
				},
			}, nil),
		)

		DescribeTable("functions get calculated", test,
			Entry("sqrt", "sqrt(9)", &optimizer.OptimizedAST{
				Node: &optimizer.OptimizedNode{
					Type:        parser.NDec,
					Value:       3.0,
					OldValue:    "",
					IsOptimized: true,
					LeftChild:   nil,
					RightChild:  nil,
				},
			}, nil),
			Entry("sin", "sin(0)", &optimizer.OptimizedAST{
				Node: &optimizer.OptimizedNode{
					Type:        parser.NDec,
					Value:       0.0,
					OldValue:    "",
					IsOptimized: true,
					LeftChild:   nil,
					RightChild:  nil,
				},
			}, nil),
			Entry("sin", "cos(1)", &optimizer.OptimizedAST{
				Node: &optimizer.OptimizedNode{
					Type:        parser.NDec,
					Value:       math.Cos(1),
					OldValue:    "",
					IsOptimized: true,
					LeftChild:   nil,
					RightChild:  nil,
				},
			}, nil),
			Entry("tan", "tan(1)", &optimizer.OptimizedAST{
				Node: &optimizer.OptimizedNode{
					Type:        parser.NDec,
					Value:       math.Tan(1),
					OldValue:    "",
					IsOptimized: true,
					LeftChild:   nil,
					RightChild:  nil,
				},
			}, nil),
		)
	})

	Describe("with variables", func() {
		DescribeTable("simple varibles", test,
			Entry("simple variable", "a", &optimizer.OptimizedAST{
				Node: &optimizer.OptimizedNode{
					Type:        parser.NVar,
					Value:       0,
					OldValue:    "a",
					IsOptimized: false,
					LeftChild:   nil,
					RightChild:  nil,
				},
			}, nil),
		)

		DescribeTable("operators", test,
			Entry("addition", "1 + a", &optimizer.OptimizedAST{
				Node: &optimizer.OptimizedNode{
					Type:        parser.NAdd,
					Value:       0,
					OldValue:    "",
					IsOptimized: false,
					LeftChild: &optimizer.OptimizedNode{
						Type:        parser.NDec,
						Value:       1.0,
						OldValue:    "",
						IsOptimized: true,
						LeftChild:   nil,
						RightChild:  nil,
					},
					RightChild: &optimizer.OptimizedNode{
						Type:        parser.NVar,
						Value:       0,
						OldValue:    "a",
						IsOptimized: false,
						LeftChild:   nil,
						RightChild:  nil,
					},
				},
			}, nil),
			Entry("subtraction", "1 - a", &optimizer.OptimizedAST{
				Node: &optimizer.OptimizedNode{
					Type:        parser.NSub,
					Value:       0,
					OldValue:    "",
					IsOptimized: false,
					LeftChild: &optimizer.OptimizedNode{
						Type:        parser.NDec,
						Value:       1.0,
						OldValue:    "",
						IsOptimized: true,
						LeftChild:   nil,
						RightChild:  nil,
					},
					RightChild: &optimizer.OptimizedNode{
						Type:        parser.NVar,
						Value:       0,
						OldValue:    "a",
						IsOptimized: false,
						LeftChild:   nil,
						RightChild:  nil,
					},
				},
			}, nil),
			Entry("multiplication", "1 * a", &optimizer.OptimizedAST{
				Node: &optimizer.OptimizedNode{
					Type:        parser.NMult,
					Value:       0,
					OldValue:    "",
					IsOptimized: false,
					LeftChild: &optimizer.OptimizedNode{
						Type:        parser.NDec,
						Value:       1.0,
						OldValue:    "",
						IsOptimized: true,
						LeftChild:   nil,
						RightChild:  nil,
					},
					RightChild: &optimizer.OptimizedNode{
						Type:        parser.NVar,
						Value:       0,
						OldValue:    "a",
						IsOptimized: false,
						LeftChild:   nil,
						RightChild:  nil,
					},
				},
			}, nil),
			Entry("division", "1 / a", &optimizer.OptimizedAST{
				Node: &optimizer.OptimizedNode{
					Type:        parser.NDiv,
					Value:       0,
					OldValue:    "",
					IsOptimized: false,
					LeftChild: &optimizer.OptimizedNode{
						Type:        parser.NDec,
						Value:       1.0,
						OldValue:    "",
						IsOptimized: true,
						LeftChild:   nil,
						RightChild:  nil,
					},
					RightChild: &optimizer.OptimizedNode{
						Type:        parser.NVar,
						Value:       0,
						OldValue:    "a",
						IsOptimized: false,
						LeftChild:   nil,
						RightChild:  nil,
					},
				},
			}, nil),
		)

		DescribeTable("functions", test,
			Entry("sqrt", "sqrt(a)", &optimizer.OptimizedAST{
				Node: &optimizer.OptimizedNode{
					Type:        parser.NFnSqrt,
					Value:       0,
					OldValue:    "",
					IsOptimized: false,
					LeftChild: &optimizer.OptimizedNode{
						Type:        parser.NVar,
						Value:       0,
						OldValue:    "a",
						IsOptimized: false,
						LeftChild:   nil,
						RightChild:  nil,
					},
					RightChild: nil,
				},
			}, nil),
			Entry("sin", "sin(a)", &optimizer.OptimizedAST{
				Node: &optimizer.OptimizedNode{
					Type:        parser.NFnSin,
					Value:       0,
					OldValue:    "",
					IsOptimized: false,
					LeftChild: &optimizer.OptimizedNode{
						Type:        parser.NVar,
						Value:       0,
						OldValue:    "a",
						IsOptimized: false,
						LeftChild:   nil,
						RightChild:  nil,
					},
					RightChild: nil,
				},
			}, nil),
			Entry("cos", "cos(a)", &optimizer.OptimizedAST{
				Node: &optimizer.OptimizedNode{
					Type:        parser.NFnCos,
					Value:       0,
					OldValue:    "",
					IsOptimized: false,
					LeftChild: &optimizer.OptimizedNode{
						Type:        parser.NVar,
						Value:       0,
						OldValue:    "a",
						IsOptimized: false,
						LeftChild:   nil,
						RightChild:  nil,
					},
					RightChild: nil,
				},
			}, nil),
			Entry("tan", "tan(a)", &optimizer.OptimizedAST{
				Node: &optimizer.OptimizedNode{
					Type:        parser.NFnTan,
					Value:       0,
					OldValue:    "",
					IsOptimized: false,
					LeftChild: &optimizer.OptimizedNode{
						Type:        parser.NVar,
						Value:       0,
						OldValue:    "a",
						IsOptimized: false,
						LeftChild:   nil,
						RightChild:  nil,
					},
					RightChild: nil,
				},
			}, nil),
		)
	})
})

var _ = DescribeTable("Optimizer with custom ast",
	func(inAST *parser.AST, expOAST *optimizer.OptimizedAST, expErr error) {
		oast, err := optimizer.Optimize(inAST)
		Expect(oast).To(Equal(expOAST))
		if expErr != nil {
			Expect(err).To(Equal(expErr))
		} else {
			Expect(err).To(BeNil())
		}
	},
	Entry("handles wrong int", &parser.AST{
		Node: &parser.Node{
			Type:       parser.NInt,
			Value:      "a",
			LeftChild:  nil,
			RightChild: nil,
		},
	}, nil, calculator.ErrorInvalidInteger),
	Entry("handles wrong dec", &parser.AST{
		Node: &parser.Node{
			Type:       parser.NDec,
			Value:      "a",
			LeftChild:  nil,
			RightChild: nil,
		},
	}, nil, calculator.ErrorInvalidDecimal),

	Entry("handles invalid node type", &parser.AST{
		Node: &parser.Node{
			Type:       3000,
			Value:      "",
			LeftChild:  nil,
			RightChild: nil,
		},
	}, nil, optimizer.ErrorInvalidNodeType),

	Entry("handles, left child is missing", &parser.AST{
		Node: &parser.Node{
			Type:      parser.NAdd,
			Value:     "",
			LeftChild: nil,
			RightChild: &parser.Node{
				Type:       3000,
				Value:      "",
				LeftChild:  nil,
				RightChild: nil,
			},
		},
	}, nil, optimizer.ErrorMissingLeftChild),

	Entry("handles, right child is missing", &parser.AST{
		Node: &parser.Node{
			Type:  parser.NAdd,
			Value: "",
			LeftChild: &parser.Node{
				Type:       3000,
				Value:      "",
				LeftChild:  nil,
				RightChild: nil,
			},
			RightChild: nil,
		},
	}, nil, optimizer.ErrorMissingRightChild),

	Entry("handles, error happens in function", &parser.AST{
		Node: &parser.Node{
			Type:  parser.NFnSqrt,
			Value: "",
			LeftChild: &parser.Node{
				Type:       3000,
				Value:      "",
				LeftChild:  nil,
				RightChild: nil,
			},
			RightChild: nil,
		},
	}, nil, optimizer.ErrorInvalidNodeType),

	Entry("handles, error happens in right child", &parser.AST{
		Node: &parser.Node{
			Type:  parser.NAdd,
			Value: "",
			LeftChild: &parser.Node{
				Type:       3000,
				Value:      "",
				LeftChild:  nil,
				RightChild: nil,
			},
			RightChild: &parser.Node{
				Type:       3000,
				Value:      "",
				LeftChild:  nil,
				RightChild: nil,
			},
		},
	}, nil, optimizer.ErrorInvalidNodeType),

	Entry("handles, error happens in left child", &parser.AST{
		Node: &parser.Node{
			Type:  parser.NAdd,
			Value: "",
			LeftChild: &parser.Node{
				Type:       parser.NInt,
				Value:      "1",
				LeftChild:  nil,
				RightChild: nil,
			},
			RightChild: &parser.Node{
				Type:       3000,
				Value:      "",
				LeftChild:  nil,
				RightChild: nil,
			},
		},
	}, nil, optimizer.ErrorInvalidNodeType),
)
