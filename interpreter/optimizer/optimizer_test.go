package optimizer_test

import (
	"fmt"
	"math"
	"testing"

	. "github.com/onsi/ginkgo"
	. "github.com/onsi/ginkgo/extensions/table"
	. "github.com/onsi/gomega"
	"github.com/relnod/calcgo/interpreter/calculator"
	"github.com/relnod/calcgo/interpreter/optimizer"
	"github.com/relnod/calcgo/parser"
)

func TestOptimizer(t *testing.T) {
	RegisterFailHandler(Fail)
	RunSpecs(t, "Optimizer Suite")
}

var _ = Describe("Optimizer with ast generated by parser", func() {
	test := func(in string, expOAST *optimizer.OptimizedAST, expErr error) {
		ast, errors := parser.Parse(in)
		Expect(errors).To(BeNil())

		oast, err := optimizer.Optimize(&ast)
		Expect(oast).To(Equal(expOAST))
		if expErr != nil {
			Expect(err).To(Equal(expErr))
		} else {
			Expect(err).To(BeNil())
		}
	}
	Describe("without variables", func() {
		DescribeTable("numbers", test,
			Entry("dec stays as is", "1.3", &optimizer.OptimizedAST{
				Node: &optimizer.OptimizedNode{
					Type:  parser.NDec,
					Value: 1.3,
				},
			}, nil),
			Entry("int becomes dec", "1", &optimizer.OptimizedAST{
				Node: &optimizer.OptimizedNode{
					Type:  parser.NDec,
					Value: 1.0,
				},
			}, nil),
			Entry("bin becomes dec", "0b10", &optimizer.OptimizedAST{
				Node: &optimizer.OptimizedNode{
					Type:  parser.NDec,
					Value: 2.0,
				},
			}, nil),
			Entry("hex becomes dec", "0x10", &optimizer.OptimizedAST{
				Node: &optimizer.OptimizedNode{
					Type:  parser.NDec,
					Value: 16.0,
				},
			}, nil),
			Entry("expp becomes dec", "2^2", &optimizer.OptimizedAST{
				Node: &optimizer.OptimizedNode{
					Type:  parser.NDec,
					Value: 4.0,
				},
			}, nil),
		)

		DescribeTable("operations get calculated", test,
			Entry("addition", "1 + 1", &optimizer.OptimizedAST{
				Node: &optimizer.OptimizedNode{
					Type:  parser.NDec,
					Value: 2.0,
				},
			}, nil),
			Entry("subtraction", "1 - 1", &optimizer.OptimizedAST{
				Node: &optimizer.OptimizedNode{
					Type:  parser.NDec,
					Value: 0.0,
				},
			}, nil),
			Entry("multiplication", "2 * 1", &optimizer.OptimizedAST{
				Node: &optimizer.OptimizedNode{
					Type:  parser.NDec,
					Value: 2.0,
				},
			}, nil),
			Entry("division", "1 / 2", &optimizer.OptimizedAST{
				Node: &optimizer.OptimizedNode{
					Type:  parser.NDec,
					Value: 0.5,
				},
			}, nil),
			Entry("handles dividing by zero", "1 / 0", nil, calculator.ErrorDivisionByZero),
			Entry("modulo", "1 % 2", &optimizer.OptimizedAST{
				Node: &optimizer.OptimizedNode{
					Type:  parser.NDec,
					Value: 1.0,
				},
			}, nil),
			Entry("or", "1 | 1", &optimizer.OptimizedAST{
				Node: &optimizer.OptimizedNode{
					Type:  parser.NDec,
					Value: 1.0,
				},
			}, nil),
			Entry("xor", "1 ^ 1", &optimizer.OptimizedAST{
				Node: &optimizer.OptimizedNode{
					Type:  parser.NDec,
					Value: 0.0,
				},
			}, nil),
			Entry("and", "1 & 1", &optimizer.OptimizedAST{
				Node: &optimizer.OptimizedNode{
					Type:  parser.NDec,
					Value: 1.0,
				},
			}, nil),
		)

		DescribeTable("functions get calculated", test,
			Entry("sqrt", "sqrt(9)", &optimizer.OptimizedAST{
				Node: &optimizer.OptimizedNode{
					Type:  parser.NDec,
					Value: 3.0,
				},
			}, nil),
			Entry("sin", "sin(0)", &optimizer.OptimizedAST{
				Node: &optimizer.OptimizedNode{
					Type:  parser.NDec,
					Value: 0.0,
				},
			}, nil),
			Entry("sin", "cos(1)", &optimizer.OptimizedAST{
				Node: &optimizer.OptimizedNode{
					Type:  parser.NDec,
					Value: math.Cos(1),
				},
			}, nil),
			Entry("tan", "tan(1)", &optimizer.OptimizedAST{
				Node: &optimizer.OptimizedNode{
					Type:  parser.NDec,
					Value: math.Tan(1),
				},
			}, nil),
		)
	})

	Describe("with variables", func() {
		DescribeTable("simple varibles", test,
			Entry("simple variable", "a", &optimizer.OptimizedAST{
				Node: &parser.Node{
					Type:  parser.NVar,
					Value: "a",
				},
			}, nil),
		)

		DescribeTable("operators",
			func(op string, nodeType parser.NodeType) {
				test(fmt.Sprintf("1 %s a", op), &optimizer.OptimizedAST{
					Node: &parser.Node{
						Type:  nodeType,
						Value: "",
						LeftChild: &optimizer.OptimizedNode{
							Type:  parser.NDec,
							Value: 1.0,
						},
						RightChild: &parser.Node{
							Type:       parser.NVar,
							Value:      "a",
							LeftChild:  nil,
							RightChild: nil,
						},
					},
				}, nil)
			},
			Entry("addition", "+", parser.NAdd),
			Entry("subtraction", "-", parser.NSub),
			Entry("multiplication", "*", parser.NMult),
			Entry("division", "/", parser.NDiv),
			Entry("modulo", "%", parser.NMod),
			Entry("or", "|", parser.NOr),
			Entry("xor", "^", parser.NXor),
			Entry("and", "&", parser.NAnd),
		)

		DescribeTable("functions",
			func(fn string, nodeType parser.NodeType) {
				test(fmt.Sprintf("%s(a)", fn), &optimizer.OptimizedAST{
					Node: &parser.Node{
						Type:  nodeType,
						Value: "",
						LeftChild: &parser.Node{
							Type:       parser.NVar,
							Value:      "a",
							LeftChild:  nil,
							RightChild: nil,
						},
						RightChild: nil,
					},
				}, nil)
			},
			Entry("sqrt", "sqrt", parser.NFnSqrt),
			Entry("sin", "sin", parser.NFnSin),
			Entry("cos", "cos", parser.NFnCos),
			Entry("tan", "tan", parser.NFnTan),
		)
	})
})

var _ = DescribeTable("Optimizer with custom ast",
	func(inAST *parser.AST, expOAST *optimizer.OptimizedAST, expErr error) {
		oast, err := optimizer.Optimize(inAST)
		Expect(oast).To(Equal(expOAST))
		if expErr != nil {
			Expect(err).To(Equal(expErr))
		} else {
			Expect(err).To(BeNil())
		}
	},
	Entry("handles wrong int", &parser.AST{
		Node: &parser.Node{
			Type:       parser.NInt,
			Value:      "a",
			LeftChild:  nil,
			RightChild: nil,
		},
	}, nil, calculator.ErrorInvalidInteger),
	Entry("handles wrong dec", &parser.AST{
		Node: &parser.Node{
			Type:       parser.NDec,
			Value:      "a",
			LeftChild:  nil,
			RightChild: nil,
		},
	}, nil, calculator.ErrorInvalidDecimal),

	Entry("handles invalid node type", &parser.AST{
		Node: &parser.Node{
			Type:       3000,
			Value:      "",
			LeftChild:  nil,
			RightChild: nil,
		},
	}, nil, optimizer.ErrorInvalidNodeType),

	Entry("handles, left child is missing", &parser.AST{
		Node: &parser.Node{
			Type:      parser.NAdd,
			Value:     "",
			LeftChild: nil,
			RightChild: &parser.Node{
				Type:       3000,
				Value:      "",
				LeftChild:  nil,
				RightChild: nil,
			},
		},
	}, nil, optimizer.ErrorMissingLeftChild),

	Entry("handles, right child is missing", &parser.AST{
		Node: &parser.Node{
			Type:  parser.NAdd,
			Value: "",
			LeftChild: &parser.Node{
				Type:       3000,
				Value:      "",
				LeftChild:  nil,
				RightChild: nil,
			},
			RightChild: nil,
		},
	}, nil, optimizer.ErrorMissingRightChild),

	Entry("handles, error happens in function", &parser.AST{
		Node: &parser.Node{
			Type:  parser.NFnSqrt,
			Value: "",
			LeftChild: &parser.Node{
				Type:       3000,
				Value:      "",
				LeftChild:  nil,
				RightChild: nil,
			},
			RightChild: nil,
		},
	}, nil, optimizer.ErrorInvalidNodeType),

	Entry("handles, error happens in right child", &parser.AST{
		Node: &parser.Node{
			Type:  parser.NAdd,
			Value: "",
			LeftChild: &parser.Node{
				Type:       3000,
				Value:      "",
				LeftChild:  nil,
				RightChild: nil,
			},
			RightChild: &parser.Node{
				Type:       3000,
				Value:      "",
				LeftChild:  nil,
				RightChild: nil,
			},
		},
	}, nil, optimizer.ErrorInvalidNodeType),

	Entry("handles, error happens in left child", &parser.AST{
		Node: &parser.Node{
			Type:  parser.NAdd,
			Value: "",
			LeftChild: &parser.Node{
				Type:       parser.NInt,
				Value:      "1",
				LeftChild:  nil,
				RightChild: nil,
			},
			RightChild: &parser.Node{
				Type:       3000,
				Value:      "",
				LeftChild:  nil,
				RightChild: nil,
			},
		},
	}, nil, optimizer.ErrorInvalidNodeType),
)
